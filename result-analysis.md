# Result Type Deep Dive

- `Result<T, E>` stores the Ok payload in `#val` and the Err payload on a side-channel `#ctx.errSlot`, using the `Sentinel` symbol to indicate "no error yet". Every chaining method (`map`, `flatMap`, `zip*`, `validate`, …) allocates a fresh `ResultCtx` so that asynchronous callbacks can mutate `errSlot` later; in the happy path the promise resolves to a real value, while any failure is expected to resolve to `Sentinel` and copy the error into the new context.
- This design lets sync handlers return values directly and async handlers return promises without forcing the caller to remember whether they need to `await`. The trade-off is a fairly large surface area of overloads and bespoke helper methods whose correctness hinges on the `Sentinel` invariant and on user code never letting the internal promises reject.
- Error-handling intentionally prefers propagating thrown `Error` instances. Any non-`Error` error payload forces `unwrap`/`unwrapErr` to throw meta-errors (`UnwrappedOkWithErr`, `UnwrappedErrWithOk`) instead of the original payload.

## Potential Bugs / Risks

- **Async `validate` uses the wrong input value** (`src/result.ts:736-747`): Once `currVal` (a promise) resolves to `c`, the validators are still invoked with `currVal as T` instead of `c`. That means every validator sees the original `Promise<T>` rather than the awaited value, so validator logic that expects the concrete `T` will fail (or even pass erroneously if it only checks for truthiness). This likely slipped through because TypeScript trusts the cast. Fix is to call `v(c)` there.
- **Promise rejection breaks `Result` invariants** (e.g. `map` at `src/result.ts:223-257`, `flatMap` at `src/result.ts:309-364`, `all` at `src/result.ts:811-843`): The implementation forwards any rejection from chained promises via the `reject` branch without flipping the `Result` into the Err track. That leaves `isErr()` returning `false` forever while `unwrap()` returns a rejecting promise, and `Result.all` will reject outright instead of yielding an Err. The code relies on handlers never throwing or returning rejected promises, but that is fragile—one uncaught exception in user-space breaks the abstraction.
- **`validate` context typing is unsound** (`src/result.ts:732-784`): `mutableCtx` is declared as `ResultCtx<E>`, yet it stores arrays of validators’ error types (`VE[number][]`). Several casts (`as E`) hide this, so the type system can no longer help and future refactors risk writing the wrong shape into `errSlot`. At runtime the object still works because it is just an open slot, but we are one careless change away from losing errors.
- **`unwrap` / `unwrapErr` discard non-`Error` payloads** (`src/result.ts:31-86`): If `E` is a domain object (very common for richer error handling), `unwrap` throws `UnwrappedOkWithErr` rather than the actual payload. That makes debugging harder and diverges from Rust-style expectations where `unwrap` throws the stored `Err`. This is especially confusing when the rest of the API advertises `E` as a generic type.
- **Sentinel exposure**: Because the sentinel is a global symbol (`Symbol.for("ResultSentinel")`), any user that (intentionally or accidentally) returns the same symbol from their own code will flip a perfectly good `Ok` into a phantom `Err`. Symbols are uncommon, but this is still observable foot-gun territory.

## Recommendations

1. **Fix the async `validate` argument bug** by replacing `v(currVal as T)` with `v(c)` and add targeted tests covering both sync and async validators.
2. **Normalize promise handling**: wrap every internal `then` with a `.catch` that turns exceptions into `Result.Err`, and ensure `Result.all` catches rejections. A helper like `Result.fromPromise(p: Promise<T>): Result<Promise<T>, unknown>` (or a shared `safeThen`) would keep the logic DRY and let you enforce the resolve-to-value-or-sentinel invariant in one place.
3. **Model `errSlot` with accurate types**—e.g. promote `ResultCtx` to `ResultCtx<E>` where `E` already includes unions/arrays, or turn it into a discriminated union `{ kind: "ok" } | { kind: "err"; error: E }` to make illegal writes impossible.
4. **Revisit overload explosion**: the combinatorial overloads make the file hard to follow and may slow type checking. Introducing `type MaybePromise<T> = T | Promise<T>` and `type MaybeAsyncResult<T, E> = Result<T, E> | Promise<Result<T, E>>` would let many overloads collapse into one generic signature with conditional return types, improving maintainability.
5. **Consider making `unwrap` return/throw the exact payload** (or enforcing `E extends Error`) to avoid the current double-error pattern. If you prefer guarding against non-`Error` types, expose a dedicated `getErr(): E | null` accessor instead of throwing a meta-error.
6. **Add regression tests** covering: chained `flatMap` with async errors, `Result.all` on a mix of sync/async successes and failures, `validate` with async validators, and promise rejections bubbling through `map`/`flatMap`.

## Misc

- Extracting the sentinel + context plumbing into private utility functions (e.g. `resolveFutureOk`, `propagateErr`) would lower cognitive load and simplify new combinators.
- A lighter-weight alternative is to bifurcate the API into `Result` for sync flows and `AsyncResult` wrapping `Promise<Result<...>>`, then provide helpers to convert between them. That avoids the internal promise juggling entirely at the cost of an extra type, which might be acceptable depending on how often the async path is used.
